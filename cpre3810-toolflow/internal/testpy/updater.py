"""Updater script that dynamically updates RARS and the toolflow from gitlab.

Author:
    Braedon Giblin <bgiblin@iastate.edu>

Date: 2022.02.12
"""

import subprocess
import pathlib
import json
import shutil
import os
import re
from collections import namedtuple
import zipfile
import io
import sys

sys.path.append("internal/testpy/requestslib")
import requests

#            G1: sp  g2:22  g2: 1  g3:2
#               V     V      V       V
V_STR_RE = re.compile(r"(sp|fa)([\d]+)\.(\d+)\.(\d+)")

JOB_ID_RE = re.compile(r"jobs/([\d]+)/")

#RARS_P_TOK = os.getenv("RARS_P_TOK") # Private token, generated by Gitlab, read only
RARS_P_TOK = os.getenv("RARS_P_TOK") # Private token, generated by Gitlab, read only

TF_P_TOK = os.getenv("TF_P_TOK") # Private token, generated by Gitlab, read only
RARS_PRJ_ID = 6928 # Project ID, found on the project page of Gitlab
TF_PRJ_ID = 7023 # Project ID, found on the project page of Gitlab

rars_path = pathlib.Path('internal/Rars/RARS_CPRE3810.jar').resolve()

class Updater():
    vers = namedtuple("vers", "term year major minor")
    RARS_REL_URL = "https://git.ece.iastate.edu/api/v4/projects/{}/releases".format(RARS_PRJ_ID)
    TF_REL_URL = "https://git.ece.iastate.edu/api/v4/projects/{}/releases".format(TF_PRJ_ID)
    RARS_URL = "https://git.ece.iastate.edu/api/v4/projects/{}".format(RARS_PRJ_ID)
    TF_URL = "https://git.ece.iastate.edu/api/v4/projects/{}".format(TF_PRJ_ID)
    rars_header = {"PRIVATE-TOKEN": RARS_P_TOK}
    tf_header = {"PRIVATE-TOKEN": TF_P_TOK}

    def __init__(self, force=False, toolflow=True):
        if toolflow:
            self.remote_tf_v = self.get_remote_tf_version()
            self.curr_tf_v = self.get_current_tf_version()
            
            if (not self.tf_version_cmp()):
                print("Toolflow update available")
                self.print_tf_vers()
                if (self.y_n_req("Would you like to update the toolflow?")):
                    self.download_tf()

        self.remote_rars_v = self.get_remote_rars_version() # This must be called first to update the RARS url

        if force: # CICD Hack... this allows us to force install the latest RARS for packaging the toolflow
            self.download_rars()

        self.curr_rars_v = self.get_current_rars_version()

        if (not self.rars_version_cmp()):
            print("RARS update available")
            self.print_rars_vers()
            if (self.y_n_req("Would you like to update RARS?")):
                self.download_rars()

    def rars_version_cmp(self):
        """ Compares the current version to the compared version of rars
        
        Returns:
            true if current is up to date, else false
        """
        curr_v = self.curr_rars_v
        remote_v = self.remote_rars_v

        if(int(remote_v.year) > int(curr_v.year)):
            return False
        elif(int(remote_v.year) ==  int(curr_v.year)):
            if((curr_v.term == "sp") and (remote_v.term == "fa")):
                return False
            else:
                if(int(remote_v.major) > int(curr_v.major)):
                    return False
                elif(int(remote_v.major) == int(curr_v.major)):
                    if(int(remote_v.minor) > int(curr_v.minor)):
                        return False
                    
                
        return True

    def tf_version_cmp(self):
        """ Compares the current version to the compared version of rars
        
        Returns:
            true if current is up to date, else false
        """
        curr_v = self.curr_tf_v
        remote_v = self.remote_tf_v

        if(int(remote_v.year) > int(curr_v.year)):
            return False
        elif(int(remote_v.year) ==  int(curr_v.year)):
            if((curr_v.term == "sp") and (remote_v.term == "fa")):
                return False
            else:
                if(int(remote_v.major) > int(curr_v.major)):
                    return False
                elif(int(remote_v.major) == int(curr_v.major)):
                    if(int(remote_v.minor) > int(curr_v.minor)):
                        return False
        return True

    def download_rars(self):
        print("Downloading Rars...")
        r = requests.get(self.RARS_URL, allow_redirects=True, headers=self.rars_header)
        z = zipfile.ZipFile(io.BytesIO(r.content)).extractall(path=rars_path.parent)
        print("Done.")

    def download_tf(self):
        print("Downloading Toolflow...")
        r = requests.get(self.TF_URL, allow_redirects=True, headers=self.tf_header)
        z = zipfile.ZipFile(io.BytesIO(r.content)).extractall(path="tf.tmp")
        print("Done.")
        print("Extracting Toolflow...")
        shutil.unpack_archive("tf.tmp/cpre381-toolflow.zip", "tf.tmp", "zip")
        print("Done.")
        print("Updating...")
        shutil.rmtree("internal")
        for f in pathlib.Path("tf.tmp/cpre381-toolflow").iterdir():
            if f.is_dir():
                shutil.copytree(str(f), "internal")
            else:
                try:
                    os.remove(f.name)
                except FileNotFoundError:
                    pass
                shutil.copyfile(str(f), f.name)
        shutil.rmtree("tf.tmp")
        os.chmod("./381_tf.sh", 0o755)
        print("Done.")
        print("Exiting...")
        exit(0)
      
    def y_n_req(self, question):
        while "the answer is invalid":
            reply = str(input(question+' (y/n): ')).lower().strip()
            if reply[0] == 'y':
                return True
            if reply[0] == 'n':
                return False
    
    def get_remote_rars_version(self):
        r = requests.get(self.RARS_REL_URL, headers=self.rars_header)
        name = r.json()[0]['name']
        rars =  r.json()[0]['assets']['links'][0]['direct_asset_url']

        v = V_STR_RE.search(name)
        j = JOB_ID_RE.search(rars)
        self.RARS_URL += "/jobs/{}/artifacts".format(j[1])
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_remote_tf_version(self):
        print(self.TF_REL_URL)
        r = requests.get(self.TF_REL_URL, headers=self.tf_header)
        name = r.json()[0]['name']
        rars =  r.json()[0]['assets']['links'][0]['direct_asset_url']

        v = V_STR_RE.search(name)
        j = JOB_ID_RE.search(rars)
        self.TF_URL += "/jobs/{}/artifacts".format(j[1])
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor


    def get_current_rars_version(self):
        if (not rars_path.is_file()):
            if (self.y_n_req("RARS not installed. Would you like to download it?")):
                self.download_rars()
            else:
                print("RARS must be downloaded as {}".format(rars_path))
                exit(1)
        out = subprocess.check_output(
            ['java','-jar',rars_path,'v'],
            )
        v = V_STR_RE.search(out.decode("UTF-8"))
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_current_tf_version(self):
        if (os.path.exists("internal/version.txt")): 
            with open("internal/version.txt") as f:
                v = f.readlines()[0].strip()
        else:
            v = self.get_current_tf_from_git()
        v = V_STR_RE.search(v)
        return self.vers(v[1], v[2], v[3], v[4]) # Pack into tuple, year, major, minor

    def get_current_tf_from_git(self):
        try:
            return subprocess.check_output(
                ["git", "describe"]
            ).decode( "UTF8")
        except Exeception:
            return "sp22.0.0"
        
    def print_rars_vers(self):
        """Convenience function to print a version tuple

        """
        print("Current RARS version: {}{}.{}.{}".format(self.curr_rars_v.term,
                                self.curr_rars_v.year,
                                self.curr_rars_v.major,
                                self.curr_rars_v.minor))
        print("Available RARS version: {}{}.{}.{}".format(self.remote_rars_v.term,
                                  self.remote_rars_v.year,
                                  self.remote_rars_v.major,
                                  self.remote_rars_v.minor))
        
    def print_tf_vers(self):
        """Convenience function to print a version tuple

        """
        print("Current Toolflow  version: {}{}.{}.{}".format(self.curr_tf_v.term,
                                self.curr_tf_v.year,
                                self.curr_tf_v.major,
                                self.curr_tf_v.minor))
        print("Available Toolflow  version: {}{}.{}.{}".format(self.remote_tf_v.term,
                                  self.remote_tf_v.year,
                                  self.remote_tf_v.major,
                                  self.remote_tf_v.minor))
        
if __name__ == "__main__":
    u = Updater(force=True, toolflow=False)
    
    


